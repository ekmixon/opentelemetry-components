// Code generated by mdatagen. DO NOT EDIT.

package metadata

import (
	"go.opentelemetry.io/collector/config"
	"go.opentelemetry.io/collector/model/pdata"
)

// Type is the component type name.
const Type config.Type = "mongodbreceiver"

// MetricIntf is an interface to generically interact with generated metric.
type MetricIntf interface {
	Name() string
	New() pdata.Metric
	Init(metric pdata.Metric)
}

// Intentionally not exposing this so that it is opaque and can change freely.
type metricImpl struct {
	name     string
	initFunc func(pdata.Metric)
}

// Name returns the metric name.
func (m *metricImpl) Name() string {
	return m.name
}

// New creates a metric object preinitialized.
func (m *metricImpl) New() pdata.Metric {
	metric := pdata.NewMetric()
	m.Init(metric)
	return metric
}

// Init initializes the provided metric object.
func (m *metricImpl) Init(metric pdata.Metric) {
	m.initFunc(metric)
}

type metricStruct struct {
	MongodbCacheHits          MetricIntf
	MongodbCacheMisses        MetricIntf
	MongodbCollections        MetricIntf
	MongodbConnections        MetricIntf
	MongodbDataSize           MetricIntf
	MongodbExtents            MetricIntf
	MongodbGlobalLockHoldTime MetricIntf
	MongodbIndexSize          MetricIntf
	MongodbIndexes            MetricIntf
	MongodbMemoryUsage        MetricIntf
	MongodbObjects            MetricIntf
	MongodbOperations         MetricIntf
	MongodbStorageSize        MetricIntf
}

// Names returns a list of all the metric name strings.
func (m *metricStruct) Names() []string {
	return []string{
		"mongodb.cache.hits",
		"mongodb.cache.misses",
		"mongodb.collections",
		"mongodb.connections",
		"mongodb.data.size",
		"mongodb.extents",
		"mongodb.global_lock.hold_time",
		"mongodb.index.size",
		"mongodb.indexes",
		"mongodb.memory.usage",
		"mongodb.objects",
		"mongodb.operations",
		"mongodb.storage.size",
	}
}

var metricsByName = map[string]MetricIntf{
	"mongodb.cache.hits":            Metrics.MongodbCacheHits,
	"mongodb.cache.misses":          Metrics.MongodbCacheMisses,
	"mongodb.collections":           Metrics.MongodbCollections,
	"mongodb.connections":           Metrics.MongodbConnections,
	"mongodb.data.size":             Metrics.MongodbDataSize,
	"mongodb.extents":               Metrics.MongodbExtents,
	"mongodb.global_lock.hold_time": Metrics.MongodbGlobalLockHoldTime,
	"mongodb.index.size":            Metrics.MongodbIndexSize,
	"mongodb.indexes":               Metrics.MongodbIndexes,
	"mongodb.memory.usage":          Metrics.MongodbMemoryUsage,
	"mongodb.objects":               Metrics.MongodbObjects,
	"mongodb.operations":            Metrics.MongodbOperations,
	"mongodb.storage.size":          Metrics.MongodbStorageSize,
}

func (m *metricStruct) ByName(n string) MetricIntf {
	return metricsByName[n]
}

// Metrics contains a set of methods for each metric that help with
// manipulating those metrics.
var Metrics = &metricStruct{
	&metricImpl{
		"mongodb.cache.hits",
		func(metric pdata.Metric) {
			metric.SetName("mongodb.cache.hits")
			metric.SetDescription("The number of cache hits.")
			metric.SetUnit("1")
			metric.SetDataType(pdata.MetricDataTypeSum)
			metric.Sum().SetIsMonotonic(true)
			metric.Sum().SetAggregationTemporality(pdata.AggregationTemporalityCumulative)
		},
	},
	&metricImpl{
		"mongodb.cache.misses",
		func(metric pdata.Metric) {
			metric.SetName("mongodb.cache.misses")
			metric.SetDescription("The number of cache misses.")
			metric.SetUnit("1")
			metric.SetDataType(pdata.MetricDataTypeSum)
			metric.Sum().SetIsMonotonic(true)
			metric.Sum().SetAggregationTemporality(pdata.AggregationTemporalityCumulative)
		},
	},
	&metricImpl{
		"mongodb.collections",
		func(metric pdata.Metric) {
			metric.SetName("mongodb.collections")
			metric.SetDescription("The number of collections.")
			metric.SetUnit("1")
			metric.SetDataType(pdata.MetricDataTypeGauge)
		},
	},
	&metricImpl{
		"mongodb.connections",
		func(metric pdata.Metric) {
			metric.SetName("mongodb.connections")
			metric.SetDescription("The number of connections.")
			metric.SetUnit("1")
			metric.SetDataType(pdata.MetricDataTypeGauge)
		},
	},
	&metricImpl{
		"mongodb.data.size",
		func(metric pdata.Metric) {
			metric.SetName("mongodb.data.size")
			metric.SetDescription("The data size.")
			metric.SetUnit("By")
			metric.SetDataType(pdata.MetricDataTypeGauge)
		},
	},
	&metricImpl{
		"mongodb.extents",
		func(metric pdata.Metric) {
			metric.SetName("mongodb.extents")
			metric.SetDescription("The number of extents.")
			metric.SetUnit("1")
			metric.SetDataType(pdata.MetricDataTypeGauge)
		},
	},
	&metricImpl{
		"mongodb.global_lock.hold_time",
		func(metric pdata.Metric) {
			metric.SetName("mongodb.global_lock.hold_time")
			metric.SetDescription("The time the global lock has been held.")
			metric.SetUnit("ms")
			metric.SetDataType(pdata.MetricDataTypeSum)
			metric.Sum().SetIsMonotonic(true)
			metric.Sum().SetAggregationTemporality(pdata.AggregationTemporalityCumulative)
		},
	},
	&metricImpl{
		"mongodb.index.size",
		func(metric pdata.Metric) {
			metric.SetName("mongodb.index.size")
			metric.SetDescription("The index size.")
			metric.SetUnit("By")
			metric.SetDataType(pdata.MetricDataTypeGauge)
		},
	},
	&metricImpl{
		"mongodb.indexes",
		func(metric pdata.Metric) {
			metric.SetName("mongodb.indexes")
			metric.SetDescription("The number of indexes.")
			metric.SetUnit("1")
			metric.SetDataType(pdata.MetricDataTypeGauge)
		},
	},
	&metricImpl{
		"mongodb.memory.usage",
		func(metric pdata.Metric) {
			metric.SetName("mongodb.memory.usage")
			metric.SetDescription("The amount of memory used.")
			metric.SetUnit("By")
			metric.SetDataType(pdata.MetricDataTypeGauge)
		},
	},
	&metricImpl{
		"mongodb.objects",
		func(metric pdata.Metric) {
			metric.SetName("mongodb.objects")
			metric.SetDescription("The number of objects.")
			metric.SetUnit("1")
			metric.SetDataType(pdata.MetricDataTypeGauge)
		},
	},
	&metricImpl{
		"mongodb.operations",
		func(metric pdata.Metric) {
			metric.SetName("mongodb.operations")
			metric.SetDescription("The number of operations executed.")
			metric.SetUnit("1")
			metric.SetDataType(pdata.MetricDataTypeSum)
			metric.Sum().SetIsMonotonic(true)
			metric.Sum().SetAggregationTemporality(pdata.AggregationTemporalityCumulative)
		},
	},
	&metricImpl{
		"mongodb.storage.size",
		func(metric pdata.Metric) {
			metric.SetName("mongodb.storage.size")
			metric.SetDescription("The storage size.")
			metric.SetUnit("By")
			metric.SetDataType(pdata.MetricDataTypeGauge)
		},
	},
}

// M contains a set of methods for each metric that help with
// manipulating those metrics. M is an alias for Metrics
var M = Metrics

// Labels contains the possible metric labels that can be used.
var Labels = struct {
	// ConnectionType (The status of the connection.)
	ConnectionType string
	// DatabaseName (The name of a database.)
	DatabaseName string
	// MemoryType (The type of memory used.)
	MemoryType string
	// Operation (The mongoDB operation being counted.)
	Operation string
}{
	"connection_type",
	"database_name",
	"memory_type",
	"operation",
}

// L contains the possible metric labels that can be used. L is an alias for
// Labels.
var L = Labels

// LabelConnectionType are the possible values that the label "connection_type" can have.
var LabelConnectionType = struct {
	Active    string
	Available string
	Current   string
}{
	"active",
	"available",
	"current",
}

// LabelMemoryType are the possible values that the label "memory_type" can have.
var LabelMemoryType = struct {
	Resident          string
	Virtual           string
	Mapped            string
	MappedWithJournal string
}{
	"resident",
	"virtual",
	"mapped",
	"mappedWithJournal",
}

// LabelOperation are the possible values that the label "operation" can have.
var LabelOperation = struct {
	Insert  string
	Query   string
	Update  string
	Delete  string
	Getmore string
	Command string
}{
	"insert",
	"query",
	"update",
	"delete",
	"getmore",
	"command",
}
